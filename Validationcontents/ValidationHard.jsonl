{"id": "1", "diff": "Engineering hard", "topic": "Real Analysis", "query": "Let (f_n) be a sequence of C^1 functions on [0,1] such that (i) |f_n(x)| ≤ 1 for all x and n, (ii) (f_n') is equicontinuous and uniformly bounded on [0,1], and (iii) f_n converges pointwise to some function f. First, prove that (f_n) is relatively compact in C[0,1] with the sup norm and that every uniform limit g of a subsequence is continuously differentiable with g' the uniform limit of f_{n_k}'. Then show that the pointwise limit f is in fact C^1 and f_n → f uniformly with f_n' → f' uniformly. Explain carefully where Arzelà–Ascoli and uniqueness of limits enter. Finally, write Python code (using numpy) that numerically illustrates this phenomenon for a concrete example family f_n(x) and plots f_n, f, and their derivatives on [0,1]."}
{"id": "2", "diff": "Engineering hard", "topic": "Measure & Integration", "query": "Construct explicitly a sequence of measurable functions (f_n) on [0,1] such that f_n(x) → 0 almost everywhere, the sequence is dominated by an integrable envelope |f_n(x)| ≤ g(x) with g ∈ L^1[0,1], but the convergence of ∫_0^1 |f_n(x)| dx → 0 is very slow and highly non-uniform in n. Prove rigorously that dominated convergence applies and that ∫_0^1 f_n(x) dx → 0, and then design a second sequence (g_n) for which monotone convergence holds but dominated convergence fails due to lack of a finite integrable majorant. Explain clearly the difference between the two convergence theorems on these examples. Then write Python code that approximates ∫_0^1 f_n and ∫_0^1 g_n numerically for growing n, and plots the convergence behavior on a log scale."}
{"id": "3", "diff": "Engineering hard", "topic": "Functional Analysis", "query": "Let ℓ^2 be the Hilbert space of square-summable real sequences with inner product ⟨x,y⟩ = ∑_{k=1}^∞ x_k y_k. First, prove that every bounded linear functional T:ℓ^2→ℝ is of the form T(x) = ⟨x,y⟩ for a unique y ∈ ℓ^2 (Riesz representation theorem for ℓ^2). Then show that the operator norm of T equals the ℓ^2 norm of y. Explain carefully how completeness and the parallelogram law are used in the argument. Finally, write Python code that (i) approximates such functionals by truncating to the first N coordinates, (ii) empirically verifies ||T|| ≈ ||y||_2, and (iii) checks numerically that T(x) ≈ x·y for random high-dimensional vectors x with increasing N."}
{"id": "4", "diff": "Engineering hard", "topic": "Real Analysis / BV & AC", "query": "Let f:[0,1]→ℝ be of bounded variation. First, prove that f can be written as the difference of two increasing functions and deduce that f has at most countably many discontinuities. Then, assuming additionally that f is absolutely continuous, show that f(x) = f(0) + ∫_0^x f'(t) dt with f' ∈ L^1 and that the total variation V_0^1(f) equals ∫_0^1 |f'(t)| dt. Explain the logical relationship between bounded variation, absolute continuity, and differentiability almost everywhere. Finally, write Python code that constructs a piecewise C^1 function with many corners, numerically estimates its total variation from a fine partition, and compares this estimate with a numerical integral of |f'|."}
{"id": "5", "diff": "Engineering hard", "topic": "PDE / Sturm–Liouville", "query": "Consider the Sturm–Liouville problem on (0,π): −(p(x) y')' + q(x) y = λ w(x) y with p(x) = 1, q(x) = α sin^2 x, w(x) = 1, and boundary conditions y(0) = y(π) = 0, where α > 0 is a fixed parameter. First, prove that this defines a regular Sturm–Liouville problem whose eigenvalues form a discrete increasing sequence λ_1 < λ_2 < ⋯ → ∞ and that the eigenfunctions form an orthogonal basis of L^2(0,π). Then derive the Rayleigh quotient for this operator and obtain upper and lower bounds on λ_1 as functions of α. Explain how the min–max characterization of eigenvalues is used. Finally, write Python code that uses a spectral or finite-difference discretization to approximate the first few eigenvalues numerically for several α and compares them to your analytic bounds."}
{"id": "6", "diff": "Engineering hard", "topic": "Probability / Martingales", "query": "Let (X_n) be a sequence of independent, mean-zero random variables with |X_n| ≤ 1 almost surely and Var(X_n) = σ_n^2. Define S_n = ∑_{k=1}^n X_k and M_n = S_n^2 − ∑_{k=1}^n σ_k^2. First, prove that (M_n) is a martingale with respect to the natural filtration. Then, using an appropriate stopping time and the optional stopping theorem, derive a nontrivial inequality on P(max_{k≤n} |S_k| ≥ a) that improves on a simple union bound. Explain carefully all integrability and stopping-time conditions you need for the theorem to hold. Finally, write Python code that simulates many trajectories of S_n for a chosen distribution and numerically compares your martingale-based bound to empirical tail frequencies and to simpler bounds like Chebyshev."}
{"id": "7", "diff": "Engineering hard", "topic": "Probability / Limit Theorems", "query": "Let (X_{n,k}) be a triangular array of independent random variables with E[X_{n,k}] = 0 and Var(X_{n,k}) = σ_{n,k}^2 such that ∑_{k=1}^{m_n} σ_{n,k}^2 = 1 for each n, where m_n is the number of terms in row n. State Lindeberg's condition for this triangular array and prove that it implies convergence in distribution of S_n = ∑_{k=1}^{m_n} X_{n,k} to a standard normal. Then construct a concrete nontrivial triangular array (not just i.i.d.) for which Lindeberg holds but simple Lyapunov conditions fail. Explain intuitively why large jumps are suppressed in this construction. Finally, write Python code to simulate S_n for increasing n for your example array and produce QQ-plots comparing the empirical distribution to the standard normal."}
{"id": "8", "diff": "Engineering hard", "topic": "Complex Analysis / Normal Families", "query": "Let F be the family of holomorphic functions on the unit disk D = {z:|z|<1} satisfying |f(z)| ≤ 1/(1−|z|) for all z in D. First, prove using Montel's theorem that F is a normal family on D. Then show that if (f_n) ⊂ F converges locally uniformly to f, then either f is holomorphic and satisfies the same growth bound, or f is identically ∞ in the sense of the extended complex plane. Explain how the spherical metric and the notion of normality enter into this dichotomy. Finally, write Python code (using mpmath or sympy) to numerically explore a concrete sequence of such functions, visualize their behavior near the boundary, and illustrate convergence or blow-up on a grid of sample points."}
{"id": "9", "diff": "Engineering hard", "topic": "Complex Analysis / Argument Principle", "query": "Let p(z) be a complex polynomial of degree n with no zeros on the unit circle |z|=1. First, use the argument principle to show that the number of zeros inside the unit disk equals (1/2π) times the net change in arg p(e^{it}) as t runs from 0 to 2π. Then design a robust numerical scheme for approximating this winding number using a discrete sampling of t and appropriate unwrapping of the argument. Explain the analytic difficulties that arise when p(e^{it}) passes near the origin and how to mitigate them. Finally, write Python code that (i) takes polynomial coefficients as input, (ii) numerically estimates the number of zeros inside |z|<1 via the argument principle, and (iii) validates the result against the exact root locations from a library routine."}
{"id": "10", "diff": "Engineering hard", "topic": "Linear Algebra / Jordan & exp(A)", "query": "Let A be an n×n real matrix with a single eigenvalue λ of algebraic multiplicity n and with minimal polynomial (x−λ)^k, where 1<k≤n. First, prove that A is similar over ℝ to a Jordan matrix consisting of one or more Jordan blocks J_i of sizes summing to n, and derive a general formula for exp(tA) in terms of exp(tλ) and polynomials in t of degree at most k−1. Then, for a specific 4×4 example with two Jordan blocks (one of size 3 and one of size 1), compute exp(tA) explicitly. Explain how the nilpotent part of A controls the polynomial factors in t. Finally, write Python code using SymPy that (i) constructs your example A, (ii) computes its Jordan form, (iii) symbolically computes exp(tA), and (iv) numerically evaluates exp(tA) for several t to verify that it solves the ODE x'(t)=Ax(t) with a chosen initial vector x(0)."}

{"id": "11", "diff": "Engineering hard", "topic": "Multivariate Calculus / Implicit Function Theorem", "query": "Let F:ℝ^3→ℝ^2 be given by F(x,y,z) = (x^2 + y^2 + z^2 − 1, x^2 + y^2 − z). First, show that the set M = { (x,y,z): F(x,y,z) = (0,0) } is a smooth one-dimensional submanifold of ℝ^3 near every point with z ≠ 0, by applying the implicit function theorem. Then parameterize all connected components of M explicitly and classify their geometry (closed curve, open curve, etc.). Explain the role of the Jacobian matrix and its rank in determining the local structure of M. Finally, write Python code using SymPy that (i) computes the Jacobian of F, (ii) symbolically solves for a local parametrization near a generic point on M, and (iii) numerically samples and plots M in 3D using matplotlib."}
{"id": "12", "diff": "Engineering hard", "topic": "Vector Calculus / Differential Forms", "query": "On ℝ^3 \\ {0}, consider the 1-form ω = (−y dx + x dy)/(x^2 + y^2) + z dz/(x^2 + y^2 + z^2). First, compute dω explicitly and show that dω = 0, so ω is closed. Then prove that ω is not exact on ℝ^3 \\ {0} by integrating it over a carefully chosen closed curve and using homological/topological arguments. Explain how this relates to the nontrivial first de Rham cohomology group of the punctured space. Finally, write Python code that (i) numerically approximates the line integral of the corresponding vector field along various closed loops, and (ii) demonstrates that the integral depends on the homotopy class of the loop (e.g., loop linking the origin versus one that does not)." }
{"id": "13", "diff": "Engineering hard", "topic": "ODE / Blow-up & Global Existence", "query": "Consider the nonlinear ODE y' = y^p with initial condition y(0) = y_0 > 0, where p>1 is a real parameter. First, solve the ODE explicitly and show that the solution blows up in finite time T(y_0,p). Then take the perturbed equation y' = y^p − y and prove that solutions with y_0>0 exist globally for all t ≥ 0 and converge to a finite equilibrium. Explain carefully how a phase-line analysis and comparison principles distinguish finite-time blow-up from global existence. Finally, write Python code that (i) numerically integrates both ODEs for various p and y_0 using an adaptive solver, (ii) detects approximate blow-up times, and (iii) plots trajectories to visually compare the two behaviors."}
{"id": "14", "diff": "Engineering hard", "topic": "Real Analysis / Uniform Convergence & Differentiation", "query": "Define f_n(x) = n^{-1} sin(n^2 x) on [0,π]. First, show that f_n → 0 uniformly on [0,π], but that the derivatives f_n'(x) = cos(n^2 x) do not converge at any point. Construct a more subtle example (g_n) of C^1 functions on [0,1] that converge uniformly to a differentiable function g, while g_n' converges pointwise almost everywhere to a function h that is not continuous and not equal to g'. Prove rigorously that uniform convergence of derivatives fails, and explain which additional hypotheses guarantee that differentiation can be interchanged with taking limits. Finally, write Python code to numerically visualize f_n and g_n and their derivatives for large n, highlighting the discrepancy between limits of functions and limits of derivatives."}
{"id": "15", "diff": "Engineering hard", "topic": "Approximation Theory / Stone–Weierstrass", "query": "Let C([0,1]) be the space of continuous real-valued functions on [0,1]. Consider the subalgebra A consisting of polynomials in x and |x−1/2|, i.e., finite linear combinations of monomials x^k |x−1/2|^m. First, prove that A is a subalgebra that separates points and contains the constants, and use the Stone–Weierstrass theorem to show that A is dense in C([0,1]) with the sup norm. Then, for the specific continuous function f(x) = exp(x) on [0,1], explain how, in principle, to construct a sequence of functions from A that converges uniformly to f. Finally, write Python code that constructs and fits such approximants numerically (e.g., via least squares on a fine grid) and empirically demonstrates uniform approximation with decreasing error."}
{"id": "16", "diff": "Engineering hard", "topic": "Fourier Analysis", "query": "Let f(x) be the 2π-periodic square wave defined by f(x) = 1 for 0<x<π and f(x) = −1 for −π<x<0, extended periodically. First, compute its Fourier series explicitly and prove that the partial sums S_N(x) converge to f(x) at all points of continuity and to (f(x+)+f(x−))/2 at jump points. Then show that S_N exhibits the Gibbs phenomenon near the discontinuities and derive an asymptotic expression for the overshoot. Explain why this overshoot does not vanish as N→∞, even though the Fourier series converges pointwise. Finally, write Python code that computes S_N for increasing N, plots the partial sums near x=0 and x=π, and numerically measures the height of the overshoot to compare with the theoretical Gibbs constant."}
{"id": "17", "diff": "Engineering hard", "topic": "Real Analysis / Cantor Function", "query": "Define the standard Cantor set C ⊂ [0,1] by repeatedly removing middle thirds, and define the Cantor function F:[0,1]→[0,1]. First, prove that F is continuous, nondecreasing, and constant on intervals complementary to C, with F(0)=0 and F(1)=1. Then show that F'(x)=0 for almost every x∈[0,1], yet F is not absolutely continuous and its distributional derivative is a singular measure supported on C. Explain how this example demonstrates the strict inclusion AC ⊊ BV and illustrates singular continuous measures. Finally, write Python code that constructs an approximation of the Cantor function at finite depth, plots it, and numerically approximates the distribution of its increments over partitions that increasingly resolve the Cantor set."}
{"id": "18", "diff": "Engineering hard", "topic": "Topology & Analysis / Baire Category", "query": "Let C[0,1] be the Banach space of continuous real-valued functions on [0,1] with the sup norm. First, prove that the set of functions that are differentiable at at least one point is meagre (a countable union of nowhere dense sets) in C[0,1]. Conclude that a 'generic' continuous function is nowhere differentiable. Then, construct explicitly a continuous nowhere differentiable function (not just Weierstrass’s classical example but a modified version with adjustable parameters) and show rigorously that it fails differentiability at all points. Explain how Baire category arguments differ from measure-theoretic 'almost everywhere' statements. Finally, write Python code that numerically approximates your explicit nowhere differentiable function and estimates difference quotients at random points to empirically illustrate wild oscillations."}
{"id": "19", "diff": "Engineering hard", "topic": "Probability / Coupling & Total Variation", "query": "Let (X_n) and X be random variables on a common probability space taking values in a countable state space S. First, recall the definition of total variation distance between the laws of X_n and X, and prove that there exists a coupling (X_n',X') such that P(X_n'≠X') equals the total variation distance. Then, for a concrete Markov chain on S (e.g., a lazy random walk on a finite graph), construct an explicit coupling that yields a nontrivial bound on the mixing time to stationarity. Explain carefully how the coupling inequality relates convergence in distribution to the meeting time of the coupled processes. Finally, write Python code that simulates both the original chain and your coupling, estimates the empirical total variation distance over time, and compares it with your theoretical mixing bound."}
{"id": "20", "diff": "Engineering hard", "topic": "PDE / Energy Methods", "query": "Consider the 1D wave equation u_{tt} − c^2 u_{xx} = 0 on (0,1) with homogeneous Dirichlet boundary conditions u(0,t)=u(1,t)=0 and smooth initial data u(x,0)=f(x), u_t(x,0)=g(x). First, derive the conserved energy functional E(t) and prove that E(t) is constant in time for smooth solutions. Then introduce a small damping term u_{tt} − c^2 u_{xx} + α u_t = 0 with α>0 and show that the corresponding energy is nonincreasing and in fact decays exponentially under suitable assumptions on α. Explain how to rigorously justify integration by parts and boundary terms. Finally, write Python code that discretizes both the undamped and damped equations using a stable finite-difference scheme, computes the discrete energy, and demonstrates conservation versus decay numerically."}
{"id": "21", "diff": "Engineering hard", "topic": "Linear Algebra / SVD & PCA", "query": "Let X be an m×n data matrix (m samples, n features) with mean-centered rows. First, prove that the rank-k truncated SVD X ≈ U_k Σ_k V_k^T yields the best rank-k approximation in Frobenius norm and show that the columns of V_k provide principal directions for PCA. Then, for a dataset whose covariance matrix has a rapidly decaying spectrum except for one nearly repeated eigenvalue cluster, analyze how sensitive the principal components are to small perturbations (Davis–Kahan-type argument). Explain the geometric meaning of this sensitivity. Finally, write Python code that (i) generates a synthetic dataset with a designed covariance spectrum, (ii) computes PCA via SVD, (iii) perturbs the data with noise, and (iv) empirically measures subspace angles between the true and estimated principal subspaces as noise grows."}
{"id": "22", "diff": "Engineering hard", "topic": "Convex Optimization", "query": "Consider the convex optimization problem minimize f(x) = 1/2 x^T Q x + c^T x subject to Ax ≤ b, where Q is positive semidefinite and the feasible set is nonempty and bounded. First, derive the Lagrangian and the dual problem, state the Karush–Kuhn–Tucker (KKT) conditions, and prove that under Slater’s condition strong duality holds. Then, for a concrete nontrivial numerical example with Q singular (so the quadratic is only semi-strictly convex), analyze the set of optimal solutions and identify all primal–dual pairs satisfying KKT. Explain how degeneracy and redundant constraints affect the geometry of the solution set. Finally, write Python code using cvxpy (or a custom projected gradient) that (i) solves your example, (ii) recovers the dual variables, and (iii) numerically verifies complementary slackness and primal–dual optimality."}
{"id": "23", "diff": "Engineering hard", "topic": "Multivariate Calculus / Change of Variables", "query": "Let T:ℝ^2→ℝ^2 be the nonlinear transformation given in polar-like coordinates by T(r,θ) = (x,y) with x = r cos(θ + r^2), y = r sin(θ + r^2), mapping a domain D in (r,θ)-space onto a twisted region R in the plane. First, compute the Jacobian determinant J_T(r,θ) and show that T is locally invertible away from r=0. Then set up, but do not fully evaluate, the integral ∫∫_R e^{−(x^2 + y^2)} dA using the transformation T, and explain how the oscillating angle term affects the integration region and the Jacobian. Finally, write Python code to (i) numerically approximate J_T and visualize its magnitude over a grid, and (ii) Monte Carlo–estimate the integral over R by sampling in (r,θ)-space and comparing against the usual polar coordinate result when the twist term is removed."}
{"id": "24", "diff": "Engineering hard", "topic": "Real Analysis / Function Spaces", "query": "Let L^p[0,1] be the usual Lebesgue spaces for 1≤p≤∞. First, prove that for 1≤p<q≤∞ the inclusion L^q[0,1] ⊂ L^p[0,1] is continuous but not surjective, and construct explicit examples of functions that lie in L^p but not in L^q and vice versa when the domain is unbounded, explaining why bounded versus unbounded domains change the inclusion relations. Then, consider the sequence spaces ℓ^p and prove that ℓ^p ⊂ ℓ^q for p<q with strict inclusion. Explain intuitively why “larger p” corresponds to “smaller” sequence space. Finally, write Python code that (i) constructs numerical approximations of such functions and sequences, (ii) estimates their p-norms for various p, and (iii) empirically illustrates which norms remain finite or blow up as p varies."}
{"id": "25", "diff": "Engineering hard", "topic": "Numerical Analysis / Stability", "query": "Consider the initial value problem y' = λ y with y(0) = 1, where λ is a complex number with Re(λ) < 0. First, derive the absolute stability regions of the explicit Euler, implicit Euler, and classical 4th-order Runge–Kutta methods by applying each method to this test equation and analyzing the amplification factor. Then, for a stiff system composed of a mixture of such modes with widely separated negative real parts, explain how the stability regions determine allowable step sizes and why explicit methods become inefficient. Finally, write Python code that (i) plots the stability regions in the complex plane for each method, (ii) simulates the stiff system with different step sizes, and (iii) empirically demonstrates stable versus unstable behavior in line with the theoretical regions."}

{"id": "26", "diff": "Engineering hard", "topic": "Algorithms (C++)", "query": "Design and analyze an offline algorithm that, given up to 2×10^5 operations on a dynamic graph with n ≤ 10^5 nodes (edge insert, edge delete, and connectivity query (u,v)), computes answers for all connectivity queries in amortized near-logarithmic time. First, explain clearly how to use a DSU with rollback or a segment-tree-over-time framework to handle deletions in an offline fashion, including detailed complexity analysis and memory tradeoffs. Then write fully working, well-structured C++17 code that reads the operations from standard input, processes them offline, and prints YES/NO for each query in order."}
{"id": "27", "diff": "Engineering hard", "topic": "Data Structures (C++)", "query": "You must maintain an array a[1..n] (n ≤ 2×10^5) under two operations: (1) range chmin(l,r,x): for all i in [l,r], set a[i] = min(a[i],x); (2) range sum query(l,r) returning ∑_{i=l}^r a[i]. Design an efficient data structure (e.g., segment tree beats) that supports both operations in O(log n) amortized time. First, carefully derive the invariants and case splits that allow you to propagate chmin lazily while keeping sum, maximum, and second-maximum information correct. Then write fully working C++17 code implementing segment tree beats for this problem, including a small stress-test that compares results with a naive O(n) implementation on random tests."}
{"id": "28", "diff": "Engineering hard", "topic": "Graph Algorithms (C++)", "query": "Consider a directed graph with n ≤ 2×10^5 nodes and m ≤ 4×10^5 edges, with positive edge weights. You must answer q ≤ 2×10^5 queries of the form: given k special vertices S = {s_1,...,s_k} and a target t, compute min_i dist(s_i,t). Preprocessing is allowed, but the total complexity must be close to O((n+m) log n + q log n). First, explain in detail how to reverse the graph and use multi-source Dijkstra or an appropriate labeling scheme to answer queries efficiently without running Dijkstra per query. Then write C++17 code that reads the graph and queries, performs the preprocessing, and prints the answer for each query (or −1 if unreachable)."}
{"id": "29", "diff": "Engineering hard", "topic": "Concurrency (C++)", "query": "Design a lock-free multi-producer multi-consumer bounded queue using C++11 atomics (std::atomic) that supports push and pop with wait-free behavior under low contention and at least lock-free guarantees in general. First, explain the algorithmic idea (for example, a ring-buffer with per-slot sequence numbers or an adaptation of the Michael–Scott queue), carefully discussing memory ordering, the ABA problem, and how you guarantee correctness without global locks. Then write modern C++17 code that implements this queue as a template class, with push and pop methods that are thread-safe, and include a small multi-threaded test harness using std::thread to empirically demonstrate correct behavior under stress."}
{"id": "30", "diff": "Engineering hard", "topic": "Numerical Linear Algebra (C++)", "query": "Implement from scratch, in C++17, an iterative solver for large sparse symmetric positive definite systems Ax = b using the Conjugate Gradient (CG) method with an incomplete Cholesky preconditioner. First, derive the CG algorithm, explaining why it converges in at most n steps in exact arithmetic, and discuss how preconditioning changes the spectrum and improves convergence. Then design data structures for CSR (Compressed Sparse Row) storage, implement incomplete Cholesky factorization with a basic drop tolerance, and finally write C++ code that reads a sparse SPD matrix and a vector b, runs preconditioned CG with a stopping criterion based on relative residual, and prints the number of iterations and final residual norm."}
{"id": "31", "diff": "Engineering hard", "topic": "Distributed Systems (Java)", "query": "You are asked to implement a fault-tolerant key-value store using a simplified version of the Raft consensus protocol in Java. First, explain the core components of Raft (leader election, log replication, safety) and how a majority quorum guarantees consistency under crash failures, including a clear description of term numbers and commit indices. Then write Java code that implements a multi-node Raft simulation with a well-defined interface (e.g., appendEntry, requestVote, applyLog), plus a harness that creates several Raft nodes in separate threads, injects random message delays and crashes, and demonstrates that committed log entries remain consistent across all surviving nodes after recovery."}
{"id": "32", "diff": "Engineering hard", "topic": "Concurrent Programming (Java)", "query": "Design and implement in Java a scalable thread pool that supports work-stealing: multiple worker threads each maintain a double-ended queue of tasks, and idle workers steal tasks from others to balance load. First, explain the work-stealing idea, why it improves cache locality and reduces contention compared to a single global queue, and discuss the correctness challenges in a concurrent deque (ABA issues, memory visibility, and linearizability). Then write full Java code that implements a work-stealing executor service with submit() and shutdown() methods and demonstrates its behavior on a CPU-bound recursive task like parallel quicksort or parallel Fibonacci, including empirical timing comparisons against a naive fixed thread pool."}
{"id": "33", "diff": "Engineering hard", "topic": "Garbage Collection (Java)", "query": "Explain the design of a generational garbage collector with a copying young generation and a mark-sweep-compact old generation, including write barriers and remembered sets. Then, in Java, implement a simplified GC simulator: represent objects as nodes in a directed graph with fields, maintain from-space/to-space regions for the young generation, simulate allocation, minor collections, promotions, and major collections, and track fragmentation. Your Java program should read a scripted sequence of allocations and pointer updates, simulate the garbage collector step by step, and print detailed logs of surviving objects, promotions, and total heap usage after each collection cycle."}
{"id": "34", "diff": "Engineering hard", "topic": "Statistical Computing (R)", "query": "Consider Bayesian logistic regression with a Gaussian prior on the weights: y_i ∼ Bernoulli(sigmoid(x_i^T w)), w ∼ N(0, σ² I). First, derive the log-posterior and its gradient and Hessian with respect to w, and explain how to construct a Metropolis–Adjusted Langevin Algorithm (MALA) or Hamiltonian Monte Carlo (HMC) sampler to approximate the posterior. Then write idiomatic R code that (i) simulates a synthetic high-dimensional dataset, (ii) runs either MALA or a simplified HMC, (iii) monitors autocorrelation and effective sample size, and (iv) compares posterior mean estimates of w against the true generating parameters, including diagnostic plots."}
{"id": "35", "diff": "Engineering hard", "topic": "Time Series (R)", "query": "You are given a long univariate time series (length ~10^5) that appears to have both seasonal and non-stationary components. First, explain how to identify an appropriate ARIMA or SARIMA(p,d,q)×(P,D,Q)_s model, including unit-root tests, ACF/PACF inspection, seasonal differencing, and information criteria. Then write R code that (i) automatically performs seasonal differencing where necessary, (ii) searches over a reasonable grid of SARIMA models using AIC/BIC, (iii) fits the best model, (iv) performs full residual diagnostics (Ljung–Box, normality plots), and (v) produces k-step-ahead forecasts with confidence intervals, all wrapped into a reusable R function."}
{"id": "36", "diff": "Engineering hard", "topic": "High-Performance Computing (C++)", "query": "Design a cache- and SIMD-efficient C++17 implementation of single-precision matrix multiplication C = A×B for large dense matrices (n up to 4000) on a single machine. First, explain in detail how to use blocking/tiling, loop reordering, and vectorization (e.g., via compiler intrinsics or std::experimental::simd) to minimize cache misses and achieve high FLOP/s, including the effect of different block sizes on performance. Then write optimized C++ code that multiplies two n×n matrices stored in row-major layout, uses OpenMP for multi-core parallelism, times the computation, and reports achieved GFLOP/s for increasing n, comparing naive O(n^3) triple loops versus the optimized version."}
{"id": "37", "diff": "Engineering hard", "topic": "Compilers (C++)", "query": "Implement a miniature optimizing compiler in C++17 for a tiny expression language with integer variables, conditionals, and while loops. First, define a grammar and explain how to build an abstract syntax tree (AST) using a recursive descent parser, then describe how to translate the AST into a simple stack-based intermediate representation, and finally explain one nontrivial optimization such as common subexpression elimination or constant propagation with dead code elimination using data-flow analysis. Then write C++ code that (i) parses source code from stdin into an AST, (ii) builds a control-flow graph, (iii) runs at least one optimization pass, and (iv) interprets or emits stack-machine bytecode, showing the effect of optimization on several example programs."}
{"id": "38", "diff": "Engineering hard", "topic": "Numerical Optimization (C++/R)", "query": "Consider minimizing a smooth, possibly non-convex function f:ℝ^n→ℝ with noisy gradient evaluations. First, explain the theory behind stochastic gradient descent with variance reduction (e.g., SVRG or Adam with bias correction) and discuss convergence issues in non-convex landscapes, including saddle points. Then (i) write C++17 code that implements plain SGD, SVRG, and Adam for a given analytic f and its gradient, logging objective values over iterations, and (ii) write R code that reads the logged data, computes moving averages of the objective, and produces comparison plots showing convergence behavior and variance for the three methods on a moderately high-dimensional test function."}
{"id": "39", "diff": "Engineering hard", "topic": "Big Data (R)", "query": "You are given a dataset with 10^7 rows and ~200 features stored in a compressed on-disk format (e.g., feather or parquet). Memory is insufficient to load everything at once. First, explain strategies for scalable regression in R, such as chunked processing, bigmemory-style objects, online gradient methods, and using external-memory algorithms. Then write R code that (i) reads the data in chunks, (ii) fits a linear model using stochastic gradient descent or incremental least squares, (iii) periodically checkpoints intermediate parameter estimates, and (iv) validates the final model on a held-out subset, reporting R² and plotting convergence of the loss over passes through the data."}
{"id": "40", "diff": "Engineering hard", "topic": "Advanced Data Structures (C++)", "query": "Design a fully persistent balanced binary search tree that supports insertion, deletion, and order-statistics queries (k-th smallest and rank of key) in O(log n) per operation, while preserving access to all historical versions. First, explain how path-copying can be used with a Treap or Red–Black tree to achieve persistence, including the memory overhead and the need for structural sharing. Then write modern C++17 code implementing a persistent Treap with implicit keys that supports: (i) versioned insert/erase, (ii) find_kth(version,k), and (iii) rank(version,x). Provide a small driver that builds many versions and validates correctness against a non-persistent multiset on random tests."}
{"id": "41", "diff": "Engineering hard", "topic": "Networking (C++)", "query": "Implement a high-performance asynchronous TCP echo server in C++17 using epoll (on Linux) or IOCP (on Windows), capable of handling 10^5 concurrent connections. First, explain the reactor pattern, the difference between blocking, non-blocking, and edge-triggered I/O, and why a single-threaded event loop with a small thread pool for CPU-heavy work scales better than one-thread-per-connection. Then write C++ code that sets up the listening socket, configures non-blocking mode, registers it with epoll (or IOCP), handles accept/read/write events, gracefully closes dead connections, and measures throughput and connection counts under load."}
{"id": "42", "diff": "Engineering hard", "topic": "Parallel Programming (C++/OpenMP)", "query": "Consider solving the 2D Poisson equation −Δu = f on a square grid with Dirichlet boundary conditions using a finite-difference five-point stencil and Jacobi or Gauss–Seidel iterations. First, derive the discrete system and explain how red-black ordering enables parallelization of Gauss–Seidel, and discuss convergence in terms of spectral radius. Then write C++17 code with OpenMP pragmas that implements both Jacobi and red-black Gauss–Seidel solvers on an N×N grid, reports iteration counts needed to reach a given residual tolerance, and compares runtime and scalability as the number of threads and grid size increase."}
{"id": "43", "diff": "Engineering hard", "topic": "Object-Oriented Design (Java)", "query": "Design a fully pluggable event-sourced banking ledger system in Java that supports multiple types of accounts, transactions, and currency conversion, with strong consistency guarantees. First, explain the principles of event sourcing and CQRS (Command Query Responsibility Segregation), how to model domain events, and how replaying event streams reconstructs state. Then write Java code that defines an event hierarchy, an event store interface, an in-memory and a file-backed event store implementation, and a projection layer that materializes account balances. Include tests that simulate transfers, concurrent deposits, and replay from scratch to verify that all balances are reproduced exactly."}
{"id": "44", "diff": "Engineering hard", "topic": "Machine Learning Systems (Java)", "query": "Implement, in Java, a mini distributed parameter server for training logistic regression on a large sparse dataset partitioned across several worker nodes (simulated as threads or processes). First, explain the parameter-server architecture (centralized versus sharded), synchronous vs asynchronous updates, and the impact of stale gradients on convergence. Then write Java code that (i) stores model parameters on a central server object, (ii) spawns multiple worker threads each reading distinct partitions of sparse data, (iii) performs asynchronous SGD updates to the server, and (iv) periodically evaluates loss on a validation set, logging how convergence speed changes as you vary the degree of staleness."}
{"id": "45", "diff": "Engineering hard", "topic": "Statistical Simulation (R)", "query": "You need to estimate the probability of a rare event P(X ∈ A) for a high-dimensional random vector X using importance sampling and compare it to naive Monte Carlo. First, describe the theory of importance sampling, including variance reduction, optimal choice of proposal distribution, and diagnostics for weight degeneracy. Then write R code that (i) defines a moderately high-dimensional Gaussian model and a rare event region A (e.g., a tail event on a linear functional), (ii) implements both crude Monte Carlo and importance sampling with a carefully chosen tilted Gaussian proposal, (iii) estimates the probability and its Monte Carlo standard error for both methods, and (iv) visualizes how variance scales with sample size."}
{"id": "46", "diff": "Engineering hard", "topic": "Numerical PDEs (C++)", "query": "Implement a 1D finite-volume solver in C++17 for the inviscid Burgers' equation u_t + (u^2/2)_x = 0 with periodic boundary conditions, using a high-resolution Godunov scheme with a TVD limiter (e.g., minmod or superbee). First, derive the exact Riemann solver for Burgers' flux, explain how to construct piecewise linear reconstructions with limiters to prevent spurious oscillations, and discuss CFL constraints on the time step. Then write C++ code that (i) sets up an initial condition with both rarefaction and shock waves, (ii) runs the finite-volume scheme up to a final time, (iii) periodically outputs the solution, and (iv) compares numerical results against the analytic weak solution at selected times."}
{"id": "47", "diff": "Engineering hard", "topic": "Advanced R Programming", "query": "You are tasked with implementing an R package that provides a domain-specific language (DSL) for automatic differentiation and symbolic manipulation of vectorized statistical models (e.g., generalized linear models). First, explain how non-standard evaluation in R (quoting and quasi-quoting) can be used to capture model formulas as expression trees, and how to traverse and transform these trees to generate gradient and Hessian code. Then write R code that (i) defines a tiny DSL for specifying a log-likelihood in a formula-like syntax, (ii) builds an expression tree, (iii) symbolically differentiates it to obtain gradient expressions, (iv) JIT-compiles the resulting functions via Rcpp or compiler::cmpfun, and (v) verifies gradients numerically on a test model."}
{"id": "48", "diff": "Engineering hard", "topic": "Formal Verification (C++)", "query": "Consider a safety-critical C++17 library that implements arbitrary-precision integer arithmetic. First, explain how to model key operations (addition, subtraction, multiplication) in an SMT solver such as Z3, and how to express correctness properties (e.g., no overflow in internal fixed-size limbs, equivalence with a mathematical big-int model) as logical formulas. Then write C++ code that (i) implements a simple arbitrary-precision integer type using base-2^32 limbs, (ii) uses the Z3 C++ API to generate verification conditions for randomly generated small cases, and (iii) automatically checks, via SMT queries, that the implementation is consistent with a high-level specification on all tested instances."}
{"id": "49", "diff": "Engineering hard", "topic": "Multi-language Integration (C++/R)", "query": "You must expose a high-performance C++17 library for computing large-scale graph centrality measures (e.g., betweenness and eigenvector centrality on graphs with up to 10^6 edges) to R users. First, explain design considerations for writing a stable C++ API, avoiding unnecessary copies when moving data between R and C++, and how to use Rcpp to bridge the two worlds efficiently. Then write C++ code (with Rcpp) that (i) accepts an edge list from R, (ii) builds an adjacency structure, (iii) computes approximate betweenness centrality using a randomized algorithm (e.g., Brandes with sampling), and (iv) returns a numeric vector of scores to R. Also provide R wrapper code and an example R script that calls the functions and benchmarks them against a pure R implementation on medium-sized graphs."}
{"id": "50", "diff": "Engineering hard", "topic": "Databases (Java)", "query": "Implement, in Java, a minimal LSM-tree–based embedded key-value store supporting point lookups, range scans, and crash recovery. First, explain the architecture of an LSM tree: mutable memtable, immutable SSTables, write-ahead logging, compaction, and how Bloom filters accelerate negative lookups. Discuss write amplification and space-time tradeoffs. Then write Java code that (i) maintains an in-memory balanced tree memtable, (ii) periodically flushes it as sorted SSTable files on disk with an associated Bloom filter, (iii) supports Get and Scan operations by merging memtable and SSTables, and (iv) replays a write-ahead log on startup to ensure durability. Include a benchmark that performs mixed read/write workloads and reports throughput and latency."}
